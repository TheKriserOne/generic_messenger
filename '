use gtk4::{prelude::*, Button, Entry, Image, Label, Orientation, Stack};
use std::path::Path;
use std::sync::Mutex;
use std::{fs::File, io::Write, rc::Rc};

use super::components::components::{user_button, ChatData, DiscordUser};

use crate::discord::rest_api::utils::init_data;
use crate::discord::websocket;
use crate::{runtime, LoginInfo};

pub fn login_page(parent_stack: Rc<Stack>) {
    let login = gtk4::Box::new(Orientation::Vertical, 5);
    let token_entry = Entry::new();
    token_entry.set_placeholder_text(Some("Place token here."));
    login.append(&token_entry);

    let submit_token = Button::new();
    submit_token.set_label("Submit");
    login.append(&submit_token);
    parent_stack.add_child(&login);

    submit_token.connect_clicked(move |_| {
        let entered_token = String::from(token_entry.text());
        if entered_token.is_empty() {
            return;
        }

        let _data = match init_data(&entered_token) {
            Ok(json) => json,
            Err(_) => return,
        };
        if init_data(&entered_token).is_err() {
            eprintln!("Token invalide");
            return;
        }

        let mut data_file = File::create("./public/loginInfo").expect("creation failed");
        data_file
            .write_all(entered_token.as_bytes())
            .expect("Write Failed");

        let user = LoginInfo {
            discord_token: Some(entered_token),
        };

        chat_page(parent_stack.clone(), user);
        parent_stack.set_visible_child_name("chats");
        parent_stack.remove(&login);
    });
}

pub struct MainPanel {
    stack: gtk4::Stack,

    friend_list: gtk4::Box,
    friends: Vec<Button>,

    chat_data: ChatData,
}

impl MainPanel {
    fn new() -> Self {
        let stack = gtk4::Stack::new();

        let friend_list = gtk4::Box::new(Orientation::Vertical, 4);
        let chat = gtk4::Box::new(Orientation::Vertical, 4);

        let pfp = Image::new();
        let username = Label::new(None);
        let text_field = Entry::new();

        // Chat layout
        chat.append(&pfp);
        chat.append(&username);
        chat.append(&text_field);
        // ===

        stack.add_named(&friend_list, Some("friend_list"));
        stack.add_named(&chat, Some("chat"));

        Self {
            stack,
            friend_list,
            friends: vec![],
            chat_data: ChatData { username, pfp },
        }
    }

    fn push_friend(&mut self, user: DiscordUser) {
        let user_box = gtk4::Box::new(Orientation::Horizontal, 5);

        let username = Label::new(Some(&user.username));
        let image_path = user.pfp;
        let pfp = Image::from_file(image_path);

        user_box.append(&pfp);
        user_box.append(&username);

        let button = Button::new();
        let temp = self.stack.clone();
        button.connect_clicked(move |_| {
            temp.set_visible_child_name("chat");
        });
        button.set_child(Some(&user_box));

        self.friend_list.append(&button);
        self.friends.push(button);
    }
}

pub fn chat_page(parent_stack: Rc<Stack>, _token_data: LoginInfo) {
    runtime().spawn(async move {
        // websocket::websocket::websocket_init(&token_data.discord_token.unwrap()).await;
    });
    let sections = gtk4::Box::new(Orientation::Horizontal, 0);

    let mut main_panel = MainPanel::new();
    main_panel.push_friend(DiscordUser {
        username: "userr".to_string(),
        pfp: Path::new("public/assets/PlaceHolderPfp.jpg").to_owned(),
        id: "testing".to_string(),
    });

    // === Sidebar ===
    let sidebar = gtk4::Box::new(Orientation::Vertical, 20);

    {
        let menue = gtk4::Box::new(Orientation::Vertical, 5);
        let friends = Button::new();
        friends.set_label("Friends");
        friends.connect_clicked({
            let stack = main_panel.stack.clone();
            move |_| {
                stack.set_visible_child_name("friend_list");
            }
        });
        menue.append(&friends);
        sidebar.append(&menue);
    }

    {
        let scroll = gtk4::ScrolledWindow::new();
        scroll.set_policy(gtk4::PolicyType::Never, gtk4::PolicyType::Automatic);

        let contact_list = gtk4::Box::new(Orientation::Vertical, 5);
        let chat_data_rc = Rc::new(Mutex::new(main_panel.chat_data));
        scroll.set_child(Some(&contact_list));
        for _ in 0..20 {
            user_button(&contact_list, &main_panel.stack, chat_data_rc.clone());
        }
        sidebar.append(&scroll);
    }

    // ===
    sections.append(&sidebar);
    sections.append(&main_panel.stack);
    // sections.append(&selected_chat);

    parent_stack.add_named(&sections, Some("chats"));
}
